//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-30033411
// Cuda compilation tools, release 11.4, V11.4.48
// Based on NVVM 7.0.1
//


// extern "C" __global__ void myKernel(int* data)
// {
// 	int tid = blockIdx.x * blockDim.x + threadIdx.x;
// 	auto data = data[tid];
// 	printf("tid: %i -> %i  \n", tid, data);
// }


// PTX version
// This changes with the CUDA version whenever a new arch is released
// e.g., ampere with support for cache control
.version 7.2

//target must support the instructions we use
.target sm_35

.address_size 64

// .globl	myKernel

.extern .func  (.param .b32 func_retval0) vprintf
(
	.param .b64 vprintf_param_0,
	.param .b64 vprintf_param_1
);



// Types:
// Signed integer .s8, .s16, .s32, .s64
// Unsigned integer .u8, .u16, .u32, .u64
// Floating-point .f16, .f16x2, .f32, .f64
// Bits (untyped) .b8, .b16, .b32, .b64
// Predicate .pred

// .global Global memory, shared by all threads.
//.global .align 1 .b8 $str[11] = {116, 105, 100, 32, 61, 32, 37, 105, 32, 10, 0};

// ASCII for: (tid: %i -> %i  \n)
.global .align 1 .b8 $str[17] = {116, 105, 100, 58, 32, 37, 105, 32, 45, 62, 32, 37, 105, 32, 32, 10, 0};

.visible .entry myKernel(
	.param .u64 myKernel_param_0
)
{
	.local .align 8 .b8 	__local_depot0[8];
	// 5.4.6.  Parameterized Variable Names
	.reg .b64 	%SP;
	.reg .b64 	%SPL;
	.reg .b32 	%r<7>;
	.reg .b64 	%rd<9>;

	mov.u64 	%SPL, __local_depot0; // Move
	cvta.local.u64 	%SP, %SPL; // Convert SPL local address to genreic address

	// load the kernel parameter into rd1
	ld.param.u64 	%rd1, [myKernel_param_0];

	// Convert the pointer to a global pointer
	cvta.to.global.u64 	%rd2, %rd1;

	// read special registers
	mov.u32 	%r1, %ctaid.x;
	mov.u32 	%r2, %ntid.x;
	mov.u32 	%r3, %tid.x;


	// r1 * r2 + r3 -> ctaid * ntid + tid
	mad.lo.s32 	%r4, %r1, %r2, %r3;

	// Calculate the address by first finding the offset
	// then adding it to the base
	mul.wide.s32 	%rd3, %r4, 4;
	add.s64 	%rd4, %rd2, %rd3;

	// Load from the calculated address
	ld.global.u32 	 %r6, [%rd4];


	// printf call
	add.u64 	%rd5, %SP, 0;
	add.u64 	%rd6, %SPL, 0;
	// store a vector into rd6
	st.local.v2.u32 	[%rd6], {%r4, %r6};


	// move formatting address to rd7
	mov.u64 	%rd7, $str;

	// convert the address to a global one
	cvta.global.u64 	%rd8, %rd7;


	{ // callseq 0, 0
		.reg .b32 temp_param_reg;
		.param .b64 param0;
		st.param.b64 	[param0+0], %rd8;
		.param .b64 param1;
		st.param.b64 	[param1+0], %rd5;
		.param .b32 retval0;
		call.uni (retval0),
		vprintf,
				(
				param0,
				param1
				);
		ld.param.b32 	%r5, [retval0+0];
	} // callseq 0
	ret;
}

